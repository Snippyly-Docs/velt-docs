---
title: "Customize Behavior"
---
{/* <script>var SUPERFLOW_TOOLBAR_API_KEY="aU1MxKP0rca2UXwKi8bl"; var SUPERFLOW_TOOLBAR_PROJECT_ID="8447060215973283";</script> */}
<script id="setWindowVariableScript" src="https://snippyly-demo-html-dev.web.app/set-window-variable.js?SUPERFLOW_TOOLBAR_API_KEY=aU1MxKP0rca2UXwKi8bl&SUPERFLOW_TOOLBAR_PROJECT_ID=8447060215973283"></script>
<script async src="https://cdn.jsdelivr.net/npm/@usesuperflow/toolbar/superflow.min.js"></script>


<Tabs>
  <Tab title="React / Next.js">

## 1) Allow comments only on certain elements

Provide a list of element DOM IDs where commenting should be allowed.

Comments will be disabled for all other elements. Note, this does not impact `Popover` mode.

```js
<VeltComments allowedElementIds={['some-element']} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.allowedElementIds['some-element'];
```

## 2) Disable comments on certain elements

Disable certain elements from being commented on.

Add the `data-velt-comment-disabled` attribute to elements where you want to disable commenting.

```html
<div data-velt-comment-disabled></div>
```

## 3) File attachments

Whether file attachments are enabled.

`Default: true`

When this is on, users can attach image files to their comments. Users can download or delete an attachment. Users can attach multiple files at once.

Currently we support `.png`, `.jpg`, `.gif` (static & animated), `.svg` file types up to 2MB per file.

```js
<VeltComments attachments={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableAttachments();
commentElement.disableAttachments();
```

## 4) AI auto categorization of comments

Whether AI auto-categorization of comments is enabled.

`Default: false`

We use AI to analyze your comment content and auto-categorize it so users can filter comments easily. You can provide a list of custom categories that we should use to categorize the comments (shown below).

```js
<VeltComments autoCategorize={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableAutoCategorize();
commentElement.disableAutoCategorize();
```

## 5) Set Custom Categories

Pass custom categories in the `customCategory` prop.

`Default categories: Question, Feedback, Bug, Other.`

With custom categories, you can replace the default categories with your own values.

These categories are used in the `Comments Sidebar` to filter comments by category. The AI `autoCategorize` feature uses the list of categories to determine the closest category to choose from.

The input format to the `customCategory` prop should be an array of objects with an `id`, `name`, and `color`. 

The `color` property is used to set the category pill background color.


```js
<VeltComments customCategory={[
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
]}/>
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomCategory([
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
])
```


## 6) Comment index

Whether comment index is enabled.

`Default: false`

This appears in the comment sidebar and on the comment pins. When this is on, we show a small icon indicating the comment index in the order of creation date. This enables users to find and navigate to the desired comment quickly.

```js
<VeltComments commentIndex={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentIndex();
commentElement.disableCommentIndex();
```

## 7) Device type indicator

Whether device type indicator is enabled.

`Default: false`

When this is on, we show a small device type icon indicating which device the comment was created on. This is useful especially for design tools, where additional context is needed for debugging issues.


```js
<VeltComments deviceInfo={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeviceInfo();
commentElement.disableDeviceInfo();
```


## 8) Comment dialog on hover

Whether the comment dialog shows on hover over the comment pin or the target element.

`Default: true`

```js
<VeltComments dialogOnHover={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableDialogOnHover();
commentElement.disableDialogOnHover();
```

## 9) Comment dialog on target element click

Whether the comment dialog opens when target element is clicked. This is relevant only for Popover mode.

`Default: true`

```js
<VeltComments dialogOnTargetElementClick={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableDialogOnTargetElementClick();
commentElement.disableDialogOnTargetElementClick();
```

## 10) Floating comment dialog

Whether floating comment dialog is shown next to comment pin on hover or click.

`Default: true`

```js
<VeltComments floatingCommentDialog={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableFloatingCommentDialog();
commentElement.disableFloatingCommentDialog();
```

## 11) Ghost comments

Whether to show ghost comments on the DOM.

`Default: false`

Ghost comments are comments that were once linked to certain content on the DOM but that content is no longer available. If this is on, we display ghost comments in gray, close to where they were originally positioned on the DOM.

```js
<VeltComments ghostComments={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableGhostComments();
commentElement.disableGhostComments();
```


## 12) Ghost comments indicator

Whether to show ghost comment labels in the comment sidebar.

`Default: true`

Ghost comments are always shown in the comments sidebar so that users can see the history of all comments. If this is on, we show a label on the comment in the sidebar indicating that the original content on which this comment was added is no longer available. This sets better expectations with the users.

```js
<VeltComments ghostCommentsIndicator={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableGhostCommentsIndicator();
commentElement.disableGhostCommentsIndicator();
```

## 13) Moderator mode

Whether comments require moderator approval.

`Default: false`

By default, when a user adds a comment it is visible to all authenticated users on the same `document`. Moderator mode makes visibility of all comments private to only `admin` users and the comment author. Admin users will see an approve button on the comment dialog. Once approved the comment will be visible to all users who can access the `document`.

You can set some users as `admin` by setting the `isAdmin` property in the User object, during the `identify()` call.

```js
<VeltComments moderatorMode={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableModeratorMode();
commentElement.disableModeratorMode();
```


## 14) Priority

Whether to enable setting priority on comments.

`Default: false`

When this is on, users can assign a priority to each comment & filter comment by priority in the sidebar. You can customize the list of priority options as shown later on this page in the Set Custom Priorities section.

```js
<VeltComments priority={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enablePriority();
commentElement.disablePriority();
```


## 15) Set Custom Priorites

Pass custom priorities in the customPriority prop.

`Default priorities: P0, P1, P2`

With custom priorities, you can replace the default priorities with your own values. These priorities are also used in the comment sidebar to filter comments by priority.

This will work if you have enabled the priority feature.

The `color` property is used to set the priority pill background color.

The `lightColor` property sets the background color of the filter.


```js

<VeltComments customPriority={[
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  },
]}/>
```

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomPriority([
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  },
])
```


## 16) Resolve button

Whether to show resolve button on comments.

`Default: true`

This adds a tick mark button on the top right corner of the comment dialog. Clicking on this button will mark the comment as resolved.


```js
<VeltComments resolveButton={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableResolveButton();
commentElement.disableResolveButton();
```


## 17) Status

Whether to enable the default status dropdown & filters.

`Default: true`

When this is on, users can assign a status to each comment & filter comment by status in the sidebar. You can customize the list of status options as shown below on this page.

```js
<VeltComments status={true} />
````


API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableStatus();
commentElement.disableStatus();
```

## 18) Set Custom Statuses

Set custom statuses in the `customStatus` prop.

`Default statuses: Open, In Progress, Resolved`

With custom statuses, you can replace the default statuses with your own values. These statuses are also used in the comment sidebar to filter comments by status.

Setting the Status type using the `type` property:
  - default: This will be the default status assigned to each comment.
  - ongoing: This is treated as an intermediary status, you can add as many statuses with type ongoing as you want.
  - terminal: This represents a status that is completed. Comments with this status type are no longer shown in the DOM.

Setting the Status Icon using the `svg` property:
  - You can pass in a serialized SVG. We automatically parse and colorize SVGs. If instead you pass in an icon URL, you will have to colorize each icon yourself to match the status color.

```js
<VeltComments customStatus={[
  {
    "id": "open",
    "name": "Open",
    "color": "white",
    "lightColor:"green",
    "type": "default",
    "svg": "<svg></svg>" // Pass in a serialized SVG
  }
]}/>
```

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomStatus([
  {
    "id": "open",
    "name": "Open",
    "color": "white",
    "lightColor:"green",
    "type": "default",
    "svg": "<svg></svg>" // Pass in a serialized SVG
  }
])
```

## 19) Sign In button

Whether to enable Sign In button on comment dialog when user is anonymous or signed out.

`Default: false`

This allows anonymous or signed out users to still read the comments but encourages them to sign in if they want to respond to the comments. 


```js
<VeltComments signInButton={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableSignInButton();
commentElement.disableSignInButton();
```


## 20) onSignIn

When the user clicks on the sign in button, we will emit an onSignIn() event that you can handle with your own sign in method. 

No data is passed with the event.

```js
<VeltComments onSignIn={() => yourSignInMethod()} />
````

## 21) Attach additional context to each comment

The `onCommentAdd` event is emitted when a new comment is created. 

You can add a callback to attach additional context to each comment using the `event.addContext()` method which takes in a key-value paired object.


```js
<VeltComments onCommentAdd={(event) => yourMethod(event)} />
````

```jsx
const yourMethod = (event) => {
  event?.addContext({ customKey: 'customValue' });
}
```


### onCommentAdd Event Schema

<ResponseField name="documentId" type="string">
The document ID where the comment was added
</ResponseField>

<ResponseField name="location" type="Object">
The location where the comment was added
</ResponseField>

<ResponseField name="addContext" type="Function">
Use this to set custom data on the comment
</ResponseField>

## 22) Take action when comment is updated

The `onCommentUpdate` event is emitted when a comment is updated.

```js
<VeltComments onCommentUpdate={(event) => yourMethod(event)} />
````

### onCommentUpdate Event Schema


<ResponseField name="annotation" type="CommentAnnotation">
The annotation that is associated with the comment that was updated
</ResponseField>

<ResponseField name="type" type="string">
The type of comment that was updated
</ResponseField>

<ResponseField name="targetAnnotationId" type="string">
The ID of the target annotation that contains the comment that was updated
</ResponseField>

<ResponseField name="targetCommentId" type="number">
The ID of the target comment that was updated
</ResponseField>





## 23) Ability to accept or reject comments

Whether to enable suggestion mode to accept or reject comments.

`Default: false`

To accept comments, set the `suggestionMode` attribute to `true`.

```js
<VeltComments suggestionMode={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableSuggestionMode();
commentElement.disableSuggestionMode();
```




## 24) Listen to onCommentAccept and onCommentReject events

To listen to comments that are Accepted or Rejected in Suggestion mode, pass callbacks to the `onCommentAccept` and onCommentReject` event handlers.

```js
<VeltComments onCommentAccept={(event)=>yourMethod(event)}/>
<VeltComments onCommentReject={(event)=>yourMethod(event)}/>
```

Response:

```js
{
    "annotationId": "ANNOTATION_ID",
    "actionUser": {
        // user object
    },
    "actionType": "accept", // accept or reject
    "annotation": {
        // raw annotation object
    },
  	"replaceContentHtml": "HTML_FORMATTED_TEXT_TO_REPLACE", // optional
  	"replaceContentText": "PLAIN_TEXT_TO_REPLACE", // optional
}
```


## 25) To retrieve comments in the frontend

To retrieve all comments in the frontend, call getCommentElement() on the Velt client and then `subscribe()` to `getAllCommentAnnotations()` and pass in a callback function.

Whenever there is a change to the comments structure, the callback function will be triggered and will contain all current comments in an array.

```js
if (client) {
  const commentElement = client.getCommentElement();
  commentElement.getAllCommentAnnotations().subscribe((comments) => {
    // Do something with comments
  });
}
```

## 26) To retrieve comments in the backend

For this you should use our Webhook service. Let's say you want to be notified whenever a comment is added or updated, you can provide us an endpoint and we will send the comment data to that end point as and when there is an update. You can then process it further. Note that you cannot retrieve historical comments using this.

You can enable and configure webhook in your Velt Console as shown below. After you enable this, you need to provide an endpoint url. We will make a post request to that endpoint to send the comment data.

To read more about how to configure webhooks, check out the [webhooks documentation](/webhooks/overview).

![](https://files.readme.io/0ac5e4a-image.png)

## 27) Enable Dark Mode

Whether dark mode is enabled.

`Default: false`

```js
<VeltComments darkMode={true} />
````

API Method:

```jsx
const commentElement = client.getCommentElement();
commentElement.enableDarkMode();
commentElement.disableDarkMode();
```


## 28) Show/Hide comments on DOM

Whether comments are shown on the DOM.

`Default: true`

By default, all the comments will be visible on DOM whenever we are able to detect to elements for that. But users can hide it from DOM if required.


There are 2 ways to show/hide comments on DOM:

Configuring attributes on the React Component:
```js
{/* `true` to show comments, `false` to hide comments */}
<VeltComments commentsOnDom={false} />
```

Using API methods:
```js
const commentElement = client.getCommentElement();
// to show comments on DOM
commentElement.showCommentsOnDom();
// to hide comments on DOM
commentElement.hideCommentsOnDom();
```

## 29) Enable/Disable adding comments

Whether adding comments is enabled.

`Default: true`

By default, this feature is enabled, so users can add pin comments, area comments or text comments. But if they want to disable this feature to add comments, then they can disable/enable it through the ways mentioned below:

```js
{/* `true` to enable adding comments, `false` to disable adding comments */}
<VeltComments commentTool={false} />
```

Using API methods:
```js
const commentElement = client.getCommentElement();
// to enable adding comments
commentElement.enableCommentTool();
// to disable adding comments
commentElement.disableCommentTool();
```



## 30) Listen to onCommentModeChange
To subscribe to changes in the comment mode, use the `onCommentModeChange()` method and subscribe to it with a callback function.


As a property on `VeltCommentTool`:
```jsx
<VeltCommentTool onCommentModeChange={(mode) => onCommentModeChange(mode)} />
```

API method:
```jsx
commentElement.onCommentModeChange().subscribe((mode) => {
    //mode contains the state after change
});
```


## 31) Delete comment

To delete a comment using an API call, use the `deleteComment()` method.

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  commentElement.deleteComment();
}
```

## 32) Add comment on selected text

By default, when you highlight over any text in `textMode` a Comment Tool button will appear. Clicking the button will add a comment on the highlighted text.

If you want to trigger the comment using an API method call instead of clicking the button, you can do the following:

```jsx
const commentElement = Velt.getCommentElement();
// to add comment on selected text
commentElement.addCommentOnSelectedText();
```

  </Tab>
  

</Tabs>

<RequestExample>

```js React / Next.js

import { VeltComments } from '@veltdev/react';

export default function App() {

  return (
    <>

      <div data-velt-comment-disabled> {/* 3) */}
        // This element cannot be commented on
      </div>

      <div id="some-element">
        // Only this element can be commented on if you set allowedElementIds
      </div>

      <VeltComments
        areaMode={true} {/* 1) */}
        allowedElementIds={['some-element']} {/* 2) */}
        attachments={true} {/* 3)*/}
        autoCategorize={true} {/* 4) */}
        commentIndex={true} {/* 6)*/}
        deviceInfo={true} {/* 7) */}
        dialogOnHover={true} {/* 8) */}
        dialogOnTargetElementClick={true} {/* 9) */}
        floatingCommentDialog={false} {/* 10) */}
        ghostComments={false} {/* 11) */}
        ghostCommentsIndicator={false} {/* 12) */}
        moderatorMode={true} {/* 13) */}
        priority={true} {/* 14) */}
        resolveButton={true} {/* 16) */}
        status={false} {/* 17) */}
        signInButton={true} {/* 19) */}
        onSignIn={() => yourSignInMethod()} {/* 20) */}
        onCommentAdd={() => yourMethod()} {/* 21) */}
        onCommentUpdate={() => yourMethod()} {/* 22) */}
        suggestionMode={true} {/* 23) */}
        darkMode={true}  {/* 27) */}
        commentsOnDom={false} {/* 28) */}
        commentTool={false} {/* 29) */}
        onCommentAccept={(event)=>yourMethod(event)} {/* 24) */}
        onCommentReject={(event)=>yourMethod(event)} {/* 24) */}
        {/* 5) */}
        customCategory={[ 
          {
            "id": "bug",
            "name": "Bug",
            "color": "red"
          },
        ]}
        {/* 15) */}
        customPriority={[
          {
            "id": "low",
            "name": "Low",
            "color": "red",
            "lightColor": "pink",
          },
        ]}
        {/* 18) */}
        customStatus={[
          {
            "id": "open",
            "name": "Open",
            "color": "white",
            "type": "default",
            "iconUrl": "", // Pass in an icon URL
            "svg": "<svg></svg>" // Pass in a serialized SVG
          },
        ]}

        <VeltCommentTool 
          onCommentModeChange={(mode) => onCommentModeChange(mode)} {/* 30) */}
          commentTool={false} {/* 29) */}
        /> 


      />
```

</RequestExample>
